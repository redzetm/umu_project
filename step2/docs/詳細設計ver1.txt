Umu Project Step2 詳細設計書ver1

1. 環境準備

1.1 必要パッケージのインストール

sudo apt update
sudo apt install -y build-essential bc bison flex libssl-dev \
  libelf-dev libncurses-dev dwarves git wget \
  grub-efi-amd64-bin grub-common xorriso mtools \
  qemu-system-x86 ovmf \
  cpio gzip busybox-static

※現在の環境にすでに導入済みのPKGもあるが、Ubuntuでは、上書きは問題ないので
このコマンドラインでも大丈夫です！


各PKGの説明
build-essential
  build-essential は UbuntuやDebian系Linuxでソフトウェア開発に必須と
  される基本的なツール群をまとめたメタパッケージです。
  C/C++コンパイラやmakeなどを一括で導入でき、特に Debianパッケージの
  構築環境を整えるために必須とされています。
  - gcc : GNU Cコンパイラ
  - g++ : GNU C++コンパイラ
  - make : ビルド制御ユーティリティ
  - libc6-dev : GNU Cライブラリの開発用ヘッダ・ライブラリ
  - dpkg-dev : Debianパッケージ開発ツール
  - 用途
  - ソースコードからのビルド環境構築
  - Debianパッケージの作成・ビルド
  - C/C++開発の基本環境整備

bc
  bc は 任意精度の計算が可能なコマンドライン電卓兼簡易言語で、
  Linux環境で数値計算を行う際に利用されます。シェルスクリプトに組み込んで
  計算処理を自動化できるため、ビルド環境やカーネル開発の補助ツールとしてもよく使われます。
  〇なぜ環境構築で必要か
  LinuxカーネルやOS関連のビルド手順では、バージョン番号の計算やサイズ計算などを
  スクリプト内で行う場面が多くあります。
  bc はその計算処理を担うため、開発環境の必須パッケージに含まれています。

bisonとflex
  LinuxカーネルやOS自作のビルド環境では、構文解析器を
  生成する必要がある場面（設定ファイルの解釈、ビルドツールの内部処理など）があり、
  bison はそのための必須ツールとしてインストールされます。特に flex と
  セットで使われることが多いです。
  カーネルや関連ツールのビルド工程で利用される
  Linuxカーネルや周辺ユーティリティのソースコードには、構文解析器（パーサ）が必要な
  部分があります。例えば、カーネルの設定ファイルや一部のビルドスクリプトは 
  Yacc/Bison形式の文法定義を使っており、これをコンパイルするために bison が必須です。
  Linuxカーネルをソースからビルドする場合、カーネルの scripts/kconfig や 
  genksyms などの内部ツールが bison/flex に依存しており、これらが無いと
  ビルド途中でエラーになります。

libssl-dev
  libssl-dev は OpenSSL ライブラリの開発用パッケージです。
  OpenSSL は暗号化通信（SSL/TLS）や暗号アルゴリズムを提供するライブラリで、
  libssl-dev はその ヘッダファイルやスタティックライブラリを含んでおり、
  ソフトウェアをビルドするときに OpenSSL を利用できるようにします。
  主な役割
  - 暗号化機能の提供
  AES、DES、RSA、SHA、MD5 などの暗号アルゴリズムを利用可能。
  - SSL/TLS 通信のサポート
  HTTPS やセキュアなソケット通信を実装する際に必要。
  - 開発用ヘッダファイルを提供
  /usr/include/openssl/ 以下に配置され、C/C++ プログラムから OpenSSL API を呼び出せる。
  - ビルド時にリンク可能
  -lssl -lcrypto を指定してプログラムに組み込む。
  
  ※今回のStep2の仕様では、不要だが、推奨PKGであるために環境構築を一度で完了させる狙いで
  installしておく。

libelf-dev
  libelf-dev は ELF (Executable and Linkable Format) ファイルを読み書きするための
  開発用ライブラリです。ELF は Linux や Unix 系 OS で標準的に使われる、
  実行ファイル／オブジェクトファイル／共有ライブラリのフォーマットであり、
  libelf-dev をインストールすることで、ELF ファイルを操作するプログラムを
  ビルドできるようになります。
  主な役割
  - ELFファイルの読み書き
    実行ファイルやカーネルモジュールのバイナリ構造を解析・編集可能。
  - 開発用ヘッダファイルの提供
    /usr/include/elf.h などのヘッダを含み、C/C++ から ELF API を利用できる。
  - カーネルビルドで必須
    Linuxカーネルのビルド工程では、モジュールやシンボル情報を ELF 形式で扱うため、
    このライブラリが必要。

libncurses-dev
  libncurses-dev は ncurses ライブラリの開発用ヘッダファイルや
  静的ライブラリを提供するパッケージです。
  ncurses は「端末に依存しない文字ベースの画面制御」を行うためのライブラリで、
  CUI（キャラクタユーザインターフェース）プログラムを作る際に利用されます。
  ncursesの特徴
  - 端末非依存の画面制御
    VT100 などの端末エスケープシーケンスを抽象化し、どの端末でも同じコードで動作可能。
  - 文字ベースUIの構築
    ウィンドウ分割、カーソル移動、色付け、キーボード入力、スクロールなどを簡単に実装できる。
  - 古い curses ライブラリの拡張版
    「new curses」＝ ncurses として UNIX 系環境で広く使われている。
  - 開発用ヘッダファイルを提供
    /usr/include/ncurses.h などを含み、C/C++ プログラムから ncurses API を利用可能。
  - 静的ライブラリを提供
  -lncurses を指定してリンクできる。
  - カーネルビルドで必須
    Linux カーネルの make menuconfig（対話型設定画面）で
    ncurses が利用されるため、開発環境には必ず必要。

dwarves
  dwarves は DWARF デバッグ情報を処理するためのツール群で、Linuxカーネルや 
  ELF バイナリに埋め込まれたデバッグ情報を解析・活用するために使われます。
  代表的なユーティリティに pahole があり、C構造体のメモリ配置に存在する「穴（padding）」を
  可視化することで、構造体の最適化や BTF (BPF Type Format) 情報の生成に役立ちます。
  dwarves の主な機能
  - pahole
    構造体やクラスのメモリ配置を解析し、アライメントによる隙間（padding）を表示。
    カーネル開発で構造体サイズを最適化する際に利用。
  - pfunct
    関数やインライン展開の情報を解析し、コンパイラがどのように最適化したかを確認可能。
  - codiff
    ソースコード変更がバイナリにどう影響したかを比較。
  - btfdiff
    BTF と DWARF の出力を比較し、整合性を確認。
  - その他ユーティリティ
    ELF バイナリに埋め込まれた DWARF デバッグ情報を読み取り、整形表示や解析を行う。
  - Linuxカーネルビルドで必須
    カーネルの BPF (Berkeley Packet Filter) 機能や BTF 情報生成に 
    pahole が使われるため、dwarves が無いとビルドが途中で失敗する。

git
  バージョン管理を使えるようにする

wget
  カーネルソースをダウンロード

grub-efi-amd64-bin
  grub-efi-amd64-bin は GRUB2（GRand Unified Bootloader）の EFI/UEFI 用
  モジュール群（AMD64向け）を含むパッケージです。
  UEFI 環境で OS を起動するために必要な GRUB のバイナリ部品を提供します。
  なんでAMDはついてるか？は、歴史的経緯がある。
  64bit 拡張を最初に設計したのが AMD（AMD64 アーキテクチャ）→ Intel は後から互換性を
  持つ形で採用しました（Intel64）。
  Debian/Ubuntu では「x86_64」を「amd64」と呼ぶのが慣習になっています。
  → これは「AMD が最初に提案した拡張仕様に由来する名前」であり、
  Intel CPU でも問題なく使えます。

grub-common
  grub-common は GRUB（GRand Unified Bootloader）の共通ファイル群をまとめたパッケージです。
  GRUB Legacy と GRUB2 の両方で共有されるファイルや、GRUB2 特有でも互換性を壊さない範囲の
  ファイルが含まれています。
  - GRUB の各バリエーション（BIOS版、UEFI版など）で共通して利用されるファイルを提供。
  - GRUB Legacy と GRUB2 の両方で使えるように設計されている。
  - GRUB を正しく動かすための基盤として必須

xorriso
xorriso は ISO 9660 ファイルシステムイメージを作成・操作するためのツールです。
特に GRUB の grub-mkrescue コマンドと組み合わせて、ブート可能な ISO イメージを
生成する際に利用されます。
xorriso の主な機能
  - ISOイメージの作成
    ディレクトリ構造から ISO 9660 イメージを生成。
  - ISOイメージの編集
    既存の ISO にファイルを追加・削除・更新可能。
  - ブート可能ISOの生成
    GRUB と連携して、BIOS/UEFI 両対応のブート可能 ISO を作成。
  - El Torito / UEFI ブート対応
    CD/DVD/USB から起動できる ISO を作る際に必須。
  - grub-mkrescue が内部で xorriso を呼び出す
  GRUB を組み込んだ ISO を作るとき、xorriso が ISO 9660 ファイルシステムを生成する。

mtools
  Unix/Linux 環境から MS-DOS ファイルシステム（特にフロッピーディスクやそのイメージ）を
  マウントせずに直接操作できるユーティリティ集です。
  - ディスクをマウントせずに直接アクセス可能
  - DOS のコマンドに似た操作体系（例: mcopy, mdir, mtype）
  - QEMU や VirtualBox などの仮想環境でフロッピーイメージを扱う際にも利用可能

qemu-system-x86
  qemu-system-x86 は QEMU の「システムエミュレーション」モードで 
  x86 アーキテクチャを仮想化する実行ファイルです。これを使うことで、
  Intel/AMD 系 CPU（32bit/64bit）の仮想マシンを作成し、Linux や自作OSを起動・検証できます。

ovmf
  仮想マシンで UEFI を利用可能にするためのファームウェアプロジェクトで、
  QEMU や KVM などの仮想環境で UEFI ブートを実現するために使われます。
  - 仮想マシンに UEFI ファームウェア環境を提供
  - UEFI 対応 OS（Linux, Windows, 自作OSなど）を仮想環境で起動可能にする
  - BIOS ではなく UEFI を前提としたブート検証を可能にする

cpio
  UNIX 系システムで古くから使われているアーカイブ作成・展開用のコマンドラインツールで、
  ファイルやディレクトリをまとめたり展開したりする際に利用されます。
  - initramfs の生成に利用
    Linux カーネルの起動時に使われる初期 RAM ディスク (initramfs) は cpio 形式で作られる。

gzip
  GNU プロジェクトが開発したファイル圧縮コマンドで、拡張子 .gz を持つ圧縮ファイルを
  作成・展開するために使われます。

busybox-static
  busybox-static は BusyBox をスタティックリンク（静的リンク）したバイナリを
  提供するパッケージです。BusyBox は
  「小さなユーティリティをひとつの実行ファイルにまとめたツール集」で、
  Linux の組み込み環境やレスキュー環境でよく使われます。



1.2 ディレクトリ作成

mkdir -p ~/umu/step2/{kernel,initramfs,iso_root/boot/grub,logs}

2. カーネルビルド

2.1 ソース取得

cd ~/umu/step2/kernel
wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.6.58.tar.xz
tar -xf linux-6.6.58.tar.xz
cd linux-6.6.58


2.2 カーネル設定

今回はデフォルト設定でビルド。

cd linux-6.6.58
make mrproper        ※カーネルソースツリーを「完全初期化」する
make defconfig       ※Linuxカーネルのビルドにおける 「デフォルト設定ファイル（.config）の生成」 を行う
cp .config ../config-6.6.58     ※バックアップを~/umu/step2/kernelに保存

2.3 ビルド

make -j$(nproc)

※make -j$(nproc)は、make defconfigで生成した.configを使いカーネルを
ビルドする。


2.4 成果物コピー

cp arch/x86/boot/bzImage ~/umu/step2/iso_root/boot/vmlinuz-6.6.58
※bzImageをブートイメージとしてvmlinuz-6.6.58として~/umu/step2/iso_root/boot/にコピー
　vmlinuz-6.6.58は、GRUB（ブートローダー）が読み込む。

cp .config ~/umu/step2/iso_root/boot/config-6.6.58
※vmlinuz-6.6.58と同じディレクトリに入れてるけど、もしconfig-6.6.58が無くても
　影響しない。慣例的に同じディレクトリに入れてる

3. initramfs（BusyBox版）

3.1 構造作成

initramfsは、目的は「initramfs（初期RAMファイルシステム）」を構築するための作業場所。
この中で rootfs/ を作り、bin, etc, dev, proc, sys などのディレクトリを配置して、
最小限のLinux環境を再現する。
カーネルが起動直後に展開する「最初のルートファイルシステム」。
本格的なルートファイルシステムに切り替える前に、最低限のコマンドや設定を提供する。
BusyBoxを入れて ls, cat, ps, su などを使えるようにするのが典型的。

cd ~/umu/step2/initramfs
# 作業ディレクトリを initramfs に移動

mkdir -p rootfs/{bin,sbin,etc,proc,sys,dev,home/tama,root}
# initramfs 内に必要なディレクトリ構造を作成
# - bin: 基本コマンド配置
# - sbin: 管理者用コマンド配置
# - etc: 設定ファイル配置
# - proc: procfs マウントポイント
# - sys: sysfs マウントポイント
# - dev: デバイスファイル配置
# - home/tama: ユーザー tama のホームディレクトリ
# - root: root ユーザーのホームディレクトリ

cp /usr/bin/busybox rootfs/bin/
# busybox バイナリを rootfs/bin にコピー
# → initramfs 内で基本コマンドを提供するため

cd ~/umu/step2/initramfs/rootfs/bin
# busybox を配置した bin ディレクトリに移動

busybox --install -s /bin
# busybox が提供するコマンド群を /bin にシンボリックリンクとして展開
# 例: ln -s busybox ls, ln -s busybox cat など
# → initramfs 内で ls, cat, ps, su などが利用可能になる

cd ~/umu/step2/initramfs
# 作業ディレクトリを initramfs のルートに戻す


3.2 ユーザー構成

/etc/passwd と /etc/shadow を作成する。
※ /etc/passwd はユーザー情報、/etc/shadow はパスワードハッシュを保持する。
※ su による root 昇格を計画通り動作させるため、root のパスワードは必須。
※ パスワードハッシュは openssl や mkpasswd で生成し、ここに埋め込む。

# ~/umu/step2/initramfs/rootfs/etc/passwd
root:x:0:0:root:/root:/bin/sh        # root ユーザー。ホームは /root、シェルは /bin/sh
tama:x:1000:1000:tama:/home/tama:/bin/sh  # 一般ユーザー tama。ホームは /home/tama、シェルは /bin/sh


# ~/umu/step2/initramfs/rootfs/etc/shadow
# フォーマット: 
# ユーザー名:パスワードハッシュ:最終変更日:最小日数:最大日数:警告日数:非アクティブ:有効期限
# root のパスワードは必須。tama は任意だが、ログイン時にパスワード入力を求めるなら設定する。
# パスワードハッシュ生成方法:
#   1. SHA-512 方式 (openssl)
#      $ openssl passwd -6
#      → パスワードを入力すると $6$... 形式のハッシュが出力される
#
#   2. yescrypt 方式 (mkpasswd)
#      $ mkpasswd --method=yescrypt
#      → パスワードを入力すると $y$j9T$... 形式のハッシュが出力される
#
# 生成したハッシュを以下のフィールドに貼り付ける。

root:$y$j9T$exampleRootHashHere:19000:0:99999:7:::   # root のパスワードハッシュ
tama:$y$j9T$exampleTamaHashHere:19000:0:99999:7:::   # tama のパスワードハッシュ



3.3 initスクリプト作成

# ~/umu/step2/initramfs/rootfs/init

#!/bin/sh

# --- 仮想ファイルシステムのマウント ---
mount -t proc none /proc        # プロセス情報を提供する /proc をマウント
mount -t sysfs none /sys        # カーネルやデバイス情報を提供する /sys をマウント
mount -t devtmpfs none /dev     # デバイスノードを管理する /dev をマウント

# --- カーネル起動時のコマンドライン引数を取得 ---
CMDLINE=$(cat /proc/cmdline)    # GRUB から渡されたカーネルパラメータを読み込む

# --- 起動モードの判定 ---
if echo "$CMDLINE" | grep -q "single"; then
  # カーネルパラメータに "single" が含まれている場合 → シングルユーザーモード
  echo "Umu Project Step2: Single-user rescue mode"
  exec /bin/sh                   # root シェルを直接起動（パスワードなしで root ログイン）
else
  # 通常起動の場合 → マルチユーザーモード
  echo "Umu Project Step2: Multi-user mode"
  exec /bin/getty -L ttyS0 115200 vt100   # シリアルコンソールにログインプロンプトを表示
fi

chmod +x rootfs/init    #実行パーミッション追加


3.4 cpioアーカイブ作成

cd rootfs
find . | cpio -o -H newc | gzip > ../initrd.img-6.6.58
cd ..
cp initrd.img-6.6.58 ../iso_root/boot/


4. GRUB設定

# ~/umu/step2/iso_root/boot/grub/grub.cfg
set timeout=10
set default=0

menuentry "Umu Project Linux kernel 6.6.58" {
  linux /boot/vmlinuz-6.6.58 ro console=ttyS0,115200
  initrd /boot/initrd.img-6.6.58
}

menuentry "Umu Project rescue 6.6.58" {
  linux /boot/vmlinuz-6.6.58 ro single console=ttyS0,115200
  initrd /boot/initrd.img-6.6.58
}


5. ISOイメージ作成

cd ~/umu/step2
grub-mkrescue -o step2-boot.iso iso_root


6. QEMU検証

cd ~/umu/step2
qemu-system-x86_64 \
  -enable-kvm \
  -m 2048 \
  -cdrom step2-boot.iso \
  -serial stdio \
  -nographic

注意点
- -serial file:logs/serial.log を指定すると、
   標準出力がファイルにリダイレクトされ、-nographic と競合する場合がある。
- Step1で「起動しない」ケースは、シリアル出力がファイルに奪われて
   GRUBの標準出力が見えなくなったため。
- Step2では -serial stdio を利用し、シリアルを標準入出力に統一する。


7. 成功条件

- GRUBメニューが表示される
- カーネルが起動し、initramfsのログインプロンプトが表示される
- root / tama ユーザーでログイン可能
- BusyBoxコマンドが利用可能 (ls, cat, ps, su, poweroff, reboot)
- poweroff → 仮想マシン終了
- reboot → GRUB再起動

202512061233一旦完成


