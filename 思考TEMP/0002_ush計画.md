
# 0002: ush 計画（UmuOS 専用シェル）

作成日: 2026-01-30

UmuOS の現状シェルは BusyBox の `ash`。
UmuOS 専用の `ush`（Umu Shell）を検討するための「論点整理・要件定義・設計たたき台・ロードマップ」資料。

---

## 0. この資料のゴール

- 「作る/作らない」の判断材料を揃える
- 作る場合に、最初の 1 週間〜1か月で到達できる最小ラインを定義する
- 将来の拡張（スクリプト、ジョブ制御、組み込みコマンド増加）を見越し、初期設計で地雷を踏まない

---

## 1. なぜ ush を作るのか（動機の棚卸し）

### 1.1 期待できる価値（例）

- UmuOS の“学習・観測・デバッグ”に最適化した操作体系（ログ、観測、ヘルプ、可視化）
- BusyBox 依存の縮小（initramfs を軽くする／挙動を把握しやすくする）
- カーネルやユーザーランドの実験（syscall、procfs、tty、ジョブ制御、シグナル）を「使う道具」として実装できる
- UmuOS のコマンド群（umu_coreutils など）との相性最適化（補完、専用 builtins、エラー表示の統一）

### 1.2 失うもの（現実チェック）

- `ash` の成熟度（互換性・枯れた挙動・スクリプト資産）を捨てる
- シェルは“地味に広い”ため、実装範囲が膨張しやすい
- バグが OS 体験を直撃する（init 直後に壊れると詰む）

### 1.3 判断の軸（作るならどれを狙う？）

- A: **教育/実験**（最小機能・読みやすさ最優先。POSIX は部分的）
- B: **運用**（UmuOS の“標準シェル”として使う。互換性を段階的に上げる）
- C: **デバッグ用コンソール**（一般シェルというより“OS 管理ツール”）

この資料ではまず **A + C の中間（小さく作って便利にする）**を想定して書く。

---

## 2. 目的 / 非目的（最初に固定する）

### 2.1 目的（MUST）

- UmuOS 起動後に、最低限の対話操作ができる
- UmuOS のデバッグ作業を短縮する（ログ閲覧、環境確認、実行失敗の理解が速い）
- 実装を追える（コード量・依存を小さく、設計が分かりやすい）

### 2.2 非目的（WON'T / 初期はやらない）

- bash 完全互換、POSIX 完全準拠
- 高度なスクリプト機能（配列、連想配列、プロセス置換、完全な算術展開など）
- 高機能な補完（初期は不要。やるなら段階的）
- 完全なジョブ制御（最初は“最低限の Ctrl-C/終了ステータス”から）

---

## 3. ush の位置づけ（ash / sh / 専用コンソールとの違い）

### 3.1 どの程度“シェル”に寄せるか

- **“外部コマンドを起動できる REPL”**から始める（最小）
- そこに **パイプ/リダイレクト**だけ足すと実用度が急に上がる
- さらに **いくつかの builtins** を足すと“OS っぽい”体験になる

### 3.2 ash を残す/併存する案

- `init` のデフォルトは `ush` にして、壊れたとき用に `ash` を残す（安全）
- あるいは `ush` は `/bin/ush`、`ash` は `/bin/ash` として切替可能にする

---

## 4. 想定ユースケース（最重要）

ush は「誰が」「何のために」使うかで設計が変わる。

### 4.1 起動直後の定番作業

- `mount`/`ls`/`cat` で状況確認
- `dmesg`/`logread`/`tail` でログ追跡
- `ip`/`ifconfig` でネットワーク確認（将来）

### 4.2 UmuOS 固有のデバッグ

- initramfs → switch_root の成否、`/proc` `/sys` `/dev` の成立確認
- 永続ディスク `disk.img` のマウント状態・UUID の確認
- `ttyS0`/`ttyS1` の切替、シリアルログの採取

### 4.3 開発者向け機能（専用 builtins 候補）

- `help`（組み込み・用語・よくある手順を短く）
- `sysinfo`（uname、meminfo、mounts、cmdline をまとめて表示）
- `paniclog`（直近ログを決まった形式で吐く）

---

## 5. 要件（MVP / v0 / v1）

ここは“作業量の上限”を守るための柵。

### 5.1 MVP（まず動く、1〜3日）

- 対話 REPL（1行入力→実行→プロンプト）
- トークナイズ（空白区切り、クォート最小：`'...'` と `"..."`）
- `PATH` 検索して `execve`（もしくは `execvp` 相当）
- 終了ステータス `$?` 相当（内部で保持して表示できる程度でも可）
- `exit` builtin

### 5.2 v0（使える、1〜2週間）

- リダイレクト: `>` `>>` `<` `2>` `2>&1`（最初は必要最小でもよい）
- パイプ: `cmd1 | cmd2`（複数段）
- builtins: `cd` `pwd` `export` `unset` `env` `help`
- 変数展開（最小）: `$VAR` `$$` `$?`（ブレース `${VAR}` は後回し可）
- シグナル最小: Ctrl-C で前面プロセスを止める（親が死なない）
- ヒアドキュメントは後回し（実装コストが高い）

### 5.3 v1（“シェルっぽい”、1〜2か月）

- 条件実行: `&&` `||`
- コマンド連結: `;`
- 簡易スクリプト: ファイル入力で逐次実行（`ush script.ush`）
- ジョブ制御（段階的）: `&`、`jobs`、`fg`、`bg`（TTY/プロセスグループが絡む）
- `PS1`、履歴（最初はメモリのみでも可）

---

## 6. 仕様（最小文法のたたき台）

最初から完璧な文法を狙わず、段階的に拡張できる形にする。

### 6.1 トークン（初期）

- WORD
- 演算子: `|` `>` `>>` `<` `;` `&&` `||` `&`

### 6.2 AST（例）

- `Sequence`（`;`）
- `And` / `Or`（`&&` / `||`）
- `Pipeline`（`|`）
- `Command`（argv + redirects + env assignments）

### 6.3 仕様を削る方針（重要）

- 最初は「括弧」「サブシェル」「関数」「for/while」「case」などは全捨てで OK
- 書きたくなったら“外部コマンド”で代替できるか先に検討する

---

## 7. 実装設計（小さく、でも拡張できる形）

### 7.1 モジュール分割案（C想定）

- `main.c`：起動、オプション、REPL ループ
- `line_edit.c`：行入力（最初は `fgets`、後で readline 風）
- `lexer.c`：字句解析（クォート/エスケープ/演算子）
- `parser.c`：構文解析（再帰下降 or Pratt）
- `expand.c`：変数展開（v0では最小）
- `exec.c`：fork/exec、パイプ、リダイレクト
- `builtins.c`：cd/export/help など
- `error.c`：エラー表示統一（“どこで失敗したか”）

※ 最初から全部分けなくてもいいが、`lexer/exec/builtins` くらいは早めに分離すると破綻しにくい。

### 7.2 実行モデル

- 1コマンド: 親が fork → 子が exec、親は wait
- パイプ: N 個 fork、パイプ fd を適切に dup2、親は全 wait
- builtin:
	- `cd`/`export` のように **親プロセスの状態を変えるもの**は“親で実行”
	- パイプの中の builtin は子で実行（bash 的挙動に近い）

### 7.3 シグナル設計（v0の落とし穴）

- Ctrl-C（SIGINT）を ush 自身が受けて死ぬと辛い
- 前面プロセス（子）へ SIGINT を届け、親はプロンプトに戻る
- 可能なら process group / tcsetpgrp を v1 で

---

## 8. UmuOS への統合ポイント（ここが“専用”）

### 8.1 initramfs / switch_root との関係

- `init` の最後に `exec /bin/ush` する構成
- 緊急用に `ash` へフォールバックする仕組みを用意（`/bin/ash` があれば）

### 8.2 `/proc` `/sys` `/dev` を前提とした builtins

- `sysinfo`：`/proc/meminfo` `/proc/cpuinfo` `/proc/cmdline` `/proc/mounts`
- `lsdev`：`/dev` の主要デバイス存在確認（devtmpfs 成立チェック）

### 8.3 ログ・観測の標準化

- エラー表示フォーマットを固定（`ush: <stage>: <message>`）
- “再現用”にコマンド履歴をログに落とすオプション（v1以降）

---

## 9. ビルトイン候補（優先度順）

### 最初に欲しい

- `exit [code]`
- `cd [dir]`
- `pwd`
- `help`（必須：使い方が分かることが最大のUX）

### v0〜v1

- `export KEY=VALUE` / `unset KEY` / `env`
- `echo`（外部でも良いが、シェル側にあると便利）
- `type cmd`（builtin/external の判定）

### UmuOS専用（やるなら）

- `sysinfo`
- `mounts`（`/proc/mounts` を読みやすく表示）
- `paniclog`（決め打ちでログ採取→保存）

---

## 10. 互換性ポリシー（最初に宣言する）

ush は ash/bash と違う。違いは“仕様”として割り切る。

- POSIX 互換は「便利な範囲で」
- 動作が曖昧なところは **シンプルで予測可能**を優先
- “UmuOS のデバッグが楽”が最優先で、一般用途は二の次

---

## 11. セキュリティ / 安全性（小さくても最低限）

- パースエラーで落ちない（入力が変でも REPL に戻る）
- FD リークを防ぐ（パイプ/リダイレクト後に不要 FD を close）
- 可能なら `PATH` の扱いを明確化（空要素・相対 PATH をどうするか）

---

## 12. テストと検証（最小で回す）

### 12.1 ローカル（ホスト）

- トークナイザ/パーザは“ホストでユニットテスト”できると爆速
- 例: 入力→トークン列、入力→AST のスナップショット比較

### 12.2 QEMU 上（UmuOS）

- `ush` 起動→`echo ok`→パイプ→リダイレクト→終了ステータス
- 失敗系（存在しないコマンド、権限、リダイレクト先不可）

---

## 13. ロードマップ（現実的な粒度）

### Phase 0: 下ごしらえ（半日〜1日）

- `ush` をビルドして initramfs に入れる導線を作る
- `ash` フォールバック経路を確保（安全装置）

### Phase 1: MVP（1〜3日）

- REPL / exec / exit

### Phase 2: “使える”へ（1〜2週間）

- パイプ / リダイレクト / 必須 builtins / Ctrl-C

### Phase 3: “シェルっぽい”へ（1〜2か月）

- `&& || ;` / スクリプト実行 / ジョブ制御（段階）

---

## 14. 最初に決めたい具体事項（チェックリスト）

- [ ] ush の実装言語（C でいく？）
- [ ] libc は何を使う前提？（busybox環境/静的リンク/サイズ制約）
- [ ] `ush` を initramfs のどこに置く？（`/bin/ush` など）
- [ ] プロンプト（PS1）に何を出す？（`pwd`、終了コードなど）
- [ ] `PATH` のデフォルト（`/bin:/sbin:/usr/bin:/usr/sbin` など）
- [ ] `ash` 併存する？（緊急脱出路）
- [ ] UmuOS専用 builtin を最初から入れる？（`sysinfo` だけ先に入れる等）

---

## 15. メモ欄（ここから自由記述）

- 目的の優先順位:
- まず困っていること（ash で不便な点）:
- UmuOS で絶対に欲しいコマンド/体験:
- “互換性より大事”と思う哲学:

