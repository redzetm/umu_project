hello OS 設計

目的
このPJでは、OSのBIOS起動からOSの初期化initしてHelloを表示させるだけの
機能を持つが、一連の起動プロセスを研究するためのものとなる。
各ステージで「何が起きているか」を理解することが目的となります。


HelloOS設計の基本方針

■ブート環境
GRUBを利用してカーネルをロード（GRUB 2.12）
GRUBからLinuxカーネル6系を起動する流れを理解
MBRやBIOSの仕組みは「理解対象」として学習しつつ、実装はGRUBに任せる

■カーネル
Linuxカーネル6系をベースに利用（Linuxカーネル6.12 LTS）
HelloOS用に最小構成のカーネルをビルド（不要なドライバやモジュールを削る）

■initプロセス
initプロセスを自作して「Hello, OS!」を表示する
systemdのような複雑な仕組みは今回は不要する（学習コストが高い）

■動作
HelloOSでは「PID 1」が単純にHelloを表示するだけ

■研究の流れ
BIOS → GRUB → Linuxカーネルロード → initプロセス → Hello表示


■メリット
GRUBを利用することで、BIOSからカーネルロードまでの複雑な処理を省略できる
Linuxカーネル6.12 LTSを使うので、最新のカーネル構造を学べる
initプロセスを自作することでプロセス管理の根本を体験できる

##################################################################################

■検討事項
ブート方式の明確化（BIOS/UEFI をどこまで扱うか）
GRUB の設定と kernel cmdline（どのオプションが必要か）
initramfs の役割と生成方法
カーネルの初期化フェーズ（ブートローダ→解凍→init/main）
デバイスノード作成（devtmpfs / udev）と root マウント切替（pivot_root / switch_root）
PID 1 の具体的責務（reaper、SIGCHLD、シグナル伝播、子プロセス管理）
最小ユーザーランド（busybox 等）の構成と配置
コンソール/ログ出力（シリアル・VGA・dmesg/journal）
ルートファイルシステムの種類と生成（initramfs, initrd, ext4, squashfs 等）
テスト／デバッグ手法（QEMU 環境、シリアルログ、kgdb）
カーネルビルド／クロスコンパイルと設定管理（.config、不要モジュール除去）
シャットダウン/再起動の処理設計
フェールバック（起動失敗時の手順）
セキュリティ（Secure Boot 取り扱いの方針）

■追記：追加で検討すべき項目（起動フローに関する詳細）
- ブート方式の明確化
    - BIOS(MBR) と UEFI(GPT) のどちらを標準とするか、UEFI の場合は EFI システムパーティションと 
    grubx64.efi を扱う旨を記載する。
    結論
    UEFIを利用する。
    情報収集リスト
    - ESPの作成方法（パーティションサイズ、FAT32フォーマット手順）
    - GRUBのインストール方法（grub-install のUEFIオプション、efibootmgr の使い方）
    - GRUB設定ファイルの書き方（menuentry、linux、initrd の指定方法）
    - カーネルコマンドラインの必須オプション（root=, init=, console=）
    - initramfsの生成方法（cpio で自作 or dracut/mkinitramfs）
    - Secure Boot環境でのGRUB利用方法（署名付きGRUBの導入）




- GRUB 設定とカーネルコマンドライン
    - grub.cfg や kernel cmdline（console, root=, init= 等）で何を渡すかを定義する。
- initramfs の役割と生成方法
    - initramfs を使うか直接ルートに切替えるか、生成ツール（dracut, mkinitramfs, custom）を決める。
- カーネル初期化の明確化
    - ブートローダからカーネル解凍 → kernel init/main の流れと初期ログ出力の説明を追加する。
- デバイスノードとルート切替
    - devtmpfs と udev の扱い、/proc /sys /dev のマウント、pivot_root / switch_root の手順を明記する。
- PID 1（自作 init）の責務
    - PID 1 はゾンビ回収（SIGCHLD）、子プロセス管理、シグナル伝播、最小限のサービス起動／終了処理を
    実装する必要がある。
- 最小ユーザーランドの構成
    - busybox 等を使った最小ユーティリティ群、/sbin/init の配置、ファイルシステムレイアウトを決める。
- コンソールとログ
    - シリアルコンソールの有無、kernel printk レベル、dmesg/journal の取り扱いを明示する。
- ルートファイルシステム設計
    - initramfs / initrd / 実ディスク（ext4, squashfs 等）どれを採用するかと生成手順。
- 開発・テスト環境
    - QEMU による仮想テスト、シリアルログ取得、デバッグ手順（kgdb 等）を用意する。
- カーネルビルド方針
    - クロスコンパイルの有無、ターゲットアーキテクチャ、.config の管理、不要ドライバ除去方針。
- シャットダウン／再起動設計
    - PID 1 が行う終了処理、sync/umount/再起動命令の流れを決める。
- フェールセーフとデバッグ手順
    - 起動失敗時のブートログ回収、リカバリ手順、最小コンソール確保方法。
- セキュリティ方針（オプション）
    - Secure Boot を使うか、カーネル署名やブートローダ保護の方針を検討する。






















