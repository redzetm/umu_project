bootの一連の手順

手順完成版は、230行目からです。

流れ

① 電源投入
- CPUがリセットベクタから実行開始
- UEFIファームウェアが起動し、ハードウェア初期化
② UEFIがブートローダーを呼び出す（今回はGRUB2）
- UEFIはNVRAMのブートエントリを参照
- GRUB2を選択して実行
③ GRUB2の処理
- GRUB2が起動し、grub.cfg を読み込む
- ISOイメージ内のカーネルファイルをロード
- カーネルに制御を渡す
④ カーネル起動(カーネルはC言語で書く)
- カーネルが画面制御を初期化
- カーネル側のコードで以下を表示（テキストモード描画）

====================
     Umu Project
====================
と表示させる。

########
以下、上記に肉付けしていく
########

Grubで自作OSをISOブートする手順
ワクワクする最初の一歩から、ISO化・起動・ASCIIアート表示までを「
最短で確実に動く」流れに絞って案内します。
GRUBが面倒な初期化を肩代わりしてくれるので、Umu側は「VGAテキスト画面に文字を描く」
だけに集中できます。

プロジェクトの骨格
- 標準構成:
umu/
  src/
    boot.s          # Multibootヘッダ＋エントリ
    vga_text.s      # VGAテキスト描画
    link.ld         # リンカスクリプト (ELF32)
  build/
  iso_root/
    boot/
      umu.bin       # GRUBがロードする本体
      grub/
        grub.cfg    # GRUBメニュー
  Makefile

- 必要パッケージ（Ubuntu想定）:bash

sudo apt update
sudo apt install build-essential nasm xorriso grub-pc-bin grub-common

インストールするソフトウェアの説明
- build-essential → 開発環境の基盤（C/C++コンパイラやmake）※導入完了
- nasm → アセンブリ言語を機械語に変換するアセンブラ         ※導入完了
- xorriso → ISOイメージの作成・編集ツール                  ※導入完了
- grub-pc-bin → BIOS環境用GRUBモジュール                  ※導入完了
- grub-common → GRUB全般で共通利用されるツール群           ※導入完了



最小のUmu本体（Multiboot＋VGA描画）
Multibootヘッダとエントリ
- src/boot.s

; 32-bit ELF想定（GRUBがロード）
; nasm -f elf32 でアセンブル

bits 32
section .multiboot
  align 4
  MULTIBOOT_HEADER_MAGIC  equ 0x1BADB002
  MULTIBOOT_HEADER_FLAGS  equ 0x00000003   ; 必須: メモリ情報, ビデオモード
  MULTIBOOT_CHECKSUM      equ -(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)

  dd MULTIBOOT_HEADER_MAGIC
  dd MULTIBOOT_HEADER_FLAGS
  dd MULTIBOOT_CHECKSUM

section .text
global _start
extern draw_ascii

_start:
  ; GRUBはすでに保護モード。BIOS割り込みは使わない。
  ; VGAテキストバッファに直接書く。
  call draw_ascii

.hang:
  jmp .hang



VGAテキストにASCIIアートを描く
- src/vga_text.s

bits 32
section .text
global draw_ascii

; VGAテキストモード: 0xB8000 に [文字, 属性] の2バイトペアで並ぶ
; 属性例: 0x0F = 白文字・黒背景
draw_ascii:
  push ebp
  mov  ebp, esp

  ; 画面クリア（80x25）
  mov  edi, 0xB8000
  mov  ecx, 80*25
  mov  ax, 0x0720        ; ' ' + 明るい灰/黒 (例)
.clr:
  stosw
  loop .clr

  ; 表示開始位置（2行目あたり）
  mov  edi, 0xB8000 + (80*2)*2

  ; ASCIIアート文字列
  ; 改行は行オフセットを加算して処理
  ; ここでは簡易表示
  ; "Umu Project" を太字的に一行で
  mov  esi, art
  mov  bl, 0x0F          ; 白文字
.next_char:
  lodsb                   ; AL = *ESI++
  test al, al
  jz .done
  cmp  al, 10             ; LF
  jne  .print
  ; 改行: 次の行へ
  ; 現在の行頭から+80文字分進める
  ; 行頭計算は省略し「適当に」次行へ（例として+ (80 - 現在行残) は簡略）
  add  edi, (80 - 12)*2   ; この例は文字数を仮12個として次行に寄せる簡略処理
  jmp  .next_char
.print:
  mov  ah, bl             ; 属性
  mov  [edi], ax          ; [char, attr]
  add  edi, 2
  jmp  .next_char
.done:
  pop  ebp
  ret

section .rodata
art db "   _   _           ",10
    db "  | | | | _   _ _ __",10
    db "  | |_| || | | | '__|",10
    db "  |  _  || |_| | |   ",10
    db "  |_| |_| \__,_|_|   ",10
    db "      Umu Project    ",0


リンカスクリプト（ELF32, 低アドレス配置）
- src/link.ld   (Ld)

ENTRY(_start)

SECTIONS
{
  . = 0x00100000;              /* 1MiBに配置（GRUBが問題なくロード可） */

  .multiboot : { *(.multiboot) }
  .text      : { *(.text*) }
  .rodata    : { *(.rodata*) }
  .data      : { *(.data*) }
  .bss       : { *(.bss*)  }
}


ビルドとISO作成
Makefile
• 　　Makefile

TARGET := umu.bin
BUILD  := build
SRC    := src
ISO    := iso_root

NASM   := nasm
LD     := ld

all: $(BUILD)/$(TARGET) iso

$(BUILD)/$(TARGET): $(BUILD)/boot.o $(BUILD)/vga_text.o $(SRC)/link.ld
  $(LD) -m elf_i386 -T $(SRC)/link.ld -o $@ $(BUILD)/boot.o $(BUILD)/vga_text.o

$(BUILD)/boot.o: $(SRC)/boot.s
  mkdir -p $(BUILD)
  $(NASM) -f elf32 $< -o $@

$(BUILD)/vga_text.o: $(SRC)/vga_text.s
  $(NASM) -f elf32 $< -o $@

iso: $(BUILD)/$(TARGET)
  mkdir -p $(ISO)/boot/grub
  cp $(BUILD)/$(TARGET) $(ISO)/boot/$(TARGET)
  cp $(SRC)/grub.cfg     $(ISO)/boot/grub/grub.cfg
  grub-mkrescue -o umu.iso $(ISO)

clean:
  rm -rf $(BUILD) $(ISO) umu.iso


GRUBメニュー(Cfg)
• 　　src/grub.cfg

set timeout=3
set default=0

menuentry "Umu Project (ASCII Art)" {
  multiboot /boot/umu.bin
  boot
}


実行テスト
QEMUで起動確認
• 　　コマンド:bash

make
qemu-system-x86_64 -cdrom umu.iso

- 期待動作:
GRUBメニューが表示 → 「Umu Project」を選択 → 80x25のテキスト画面に
UmuのASCIIアートが描画されて止まる。

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
手順書　完成版
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃

電源投入から「Umu Project」が表示されるまでの流れ
① 電源投入とファームウェアの動作
- 電源投入: CPUはリセットベクタから実行を開始し、マザーボード上のファームウェア（UEFIまたはBIOS互換）が動き出す。
- 初期化: メモリやデバイスの簡易チェック、ストレージやキーボードなどの検出。
- 起動対象の決定: ブート順序に従って起動可能なデバイスを探し、ブートローダ（GRUBなど）を起動。

② GRUBによるカーネルの読み込み
- カーネル探索: GRUBは設定ファイルに従い、ファイルシステムからカーネルバイナリ（ELF形式）を読み込む。
- Multibootヘッダ確認: 0x1BADB002 のマジック値とフラグ・チェックサムを確認し、Multiboot対応カーネルと認識。
- 情報引き渡し: GRUBはメモリ情報やビデオ情報を構造体にまとめ、レジスタ経由でカーネルに渡す。
- エントリポイントへジャンプ: ELFのエントリ _start に制御を移す。

③ カーネル（boot.s）の開始
- 開始点: _start ラベルから実行開始。BIOS割り込みは使わず、保護モード前提。
- 初期化: スタック設定や必要ならBSS領域のクリア。
- 描画処理呼び出し: call draw_ascii により文字列描画ルーチンへ進む。
- 停止: 無限ループで待機するか、後で入力処理などを追加。

④ 画面への描画
- VGAテキストモードの場合:
- 物理アドレス 0xB8000 に文字と属性を書き込む。
- 1文字＝2バイト（ASCIIコード＋色属性）。
- 座標計算で中央に「Umu Project」を表示。
- UEFI環境の場合:
- VGAテキストがない場合はフレームバッファ情報を利用。
- ピクセル単位で描画し、文字列をビットマップフォントで表示する。

⑤ 開発手順の流れ
- アセンブル: nasm -f elf32 src/boot.s -o build/boot.o
- リンク: リンカスクリプトでMultibootヘッダを先頭に配置し、ldで結合。
- ISO作成: GRUB設定ファイル（grub.cfg）を用意し、grub-mkrescueでISO生成。
- 起動テスト: QEMUやKVMでISOを起動し、画面に「Umu Project」が出るか確認。

上記チェックリスト
開発チェックリスト
① 準備環境
- [ ] クロスコンパイラ環境（例: i686-elf-gcc, i686-elf-ld, nasm）を用意
- [ ] QEMU/KVMなどの仮想環境でテストできる状態にする
- [ ] GRUBとgrub-mkrescueが利用可能か確認

② ソースコード
- [ ] src/boot.s に Multibootヘッダ を定義
- マジック値 0x1BADB002
- フラグ 0x00000003（メモリ情報＋ビデオ）
- チェックサム -(MAGIC + FLAGS)
- [ ] _start ラベルを global 宣言
- [ ] extern draw_ascii を呼び出す処理を記述
- [ ] 無限ループで停止する処理を追加

③ リンカスクリプト
- [ ] ENTRY(_start) を指定
- [ ] .multiboot セクションを先頭（8KiB以内）に配置
- [ ] .text, .data, .bss を適切に配置

④ ビルド手順
- [ ] アセンブル:
nasm -f elf32 -o build/boot.o src/boot.s
- [ ] （必要ならCコードもコンパイル）
- [ ] リンク:
i686-elf-ld -m elf_i386 -T scripts/linker.ld -o build/umu.bin build/boot.o



⑤ GRUB設定とISO作成
- [ ] grub.cfg を作成
set timeout=0
set default=0

menuentry "Umu Project" {
    multiboot /boot/umu.bin
    boot
}
- [ ] ISO構造を作成 (boot/grub/grub.cfg と boot/umu.bin)
- [ ] ISO生成:
grub-mkrescue -o build/umu.iso build/iso



⑥ 起動テスト
- [ ] QEMUでBIOSモード起動:
qemu-system-i386 -cdrom build/umu.iso
- [ ] QEMUでUEFIモード起動（OVMF使用）:
qemu-system-x86_64 -bios ovmf.bin -cdrom build/umu.iso
- [ ] 画面に「====================」「Umu Project」が表示されるか確認

⑦ トラブルシュート
- [ ] Multibootヘッダが先頭8KiB以内にあるか
- [ ] _start が正しくリンクされているか
- [ ] VGAテキストバッファ（0xB8000）に文字が書き込まれているか
- [ ] UEFI環境で表示されない場合はフレームバッファ情報を利用する

⑧ 次の拡張ポイント
- [ ] スタック初期化
- [ ] BSS領域のクリア（C導入時）
- [ ] フレームバッファ描画対応（UEFIネイティブ用）
- [ ] 簡易ロガーや入力処理の追加













