# ush-0.0.4-基本設計書.md
UmuOS User Shell (ush) — 基本設計書（0.0.4 / 拡張）  
Target OS: UmuOS-0.1.6-dev（想定）

本書は [ush-0.0.4/docs/ush-0.0.4-仕様書.md](ush-0.0.4/docs/ush-0.0.4-仕様書.md) を、実装に落とし込むための基本設計（構成・責務・入出力・例外）として整理する。

0.0.4 は 0.0.3 をベースに「日常操作で詰まらない」ための追加仕様（`;`、最小エスケープ、`${VAR}`、グロブ、Tab補完拡張）を導入する。

---

# 1. 目的と非目的

## 1.1 目的
- UmuOS におけるユーザー向け対話シェルとして、軽量で観測可能な操作環境を提供する。
- 直列処理・成功/失敗分岐（`&&` / `||`）中心の「小物スクリプト」を ush で書けるようにする。
- 0.0.4 では、ash（/bin/sh）に逃げずに日常操作で詰まりやすい部分を ush 側で扱えるようにする。
  - コマンド区切り `;`
  - 最小のバックスラッシュエスケープ
  - `${VAR}` 展開
  - グロブ（`* ? [ ]`）
  - ファイル名（パス）Tab 補完

## 1.2 非目的（0.0.4ではやらない）
- POSIX sh / bash 互換の追求。
- ジョブ制御（バックグラウンド実行 `&`、fg/bg、`jobs` 等）。
- 制御構文（`if/for/while/case` 等）による本格スクリプト。
- 位置パラメータ（`$1`、`$@` 等）を含む引数処理。
- コマンド置換 `$(...)` / `` `...` ``。
- ヒアドキュメント（`<<` / `<<<`）。
- 高度な FD 操作（例: `2>file`、`2>&1` 等）。
- 多段パイプ（`a|b|c`）。

本格スクリプトが必要な場合は `/bin/sh`（BusyBox ash）で実行する。

---

# 2. 実行環境と運用

## 2.1 位置づけ
- `/umu_bin/ush` : ユーザー向け対話操作・軽量スクリプト（本仕様）
- `/bin/sh` : 互換性重視のスクリプト実行（BusyBox ash）

## 2.2 起動・配置
- バイナリの配置先は `/umu_bin/ush` を想定する。
- スクリプト実行（shebang）は `#!/umu_bin/ush` を想定する。

## 2.3 プロンプト設定（環境変数）
- ush はプロンプト表示のたびに `USH_PS1` → `PS1` → デフォルトの順に参照する（0.0.3 継承）。
- ush 自身は rc（例: `/etc/profile`）を自動で読まない。
  - ただし ush は親プロセスの環境変数を継承するため、親側で rc を読んで `export` 済みなら ush 側でも参照できる。

---

# 3. 全体構成

## 3.1 対話モード処理フロー（概略）
1. 親プロセスの SIGINT 方針を設定（親は落ちない）
2. プロンプトを生成・表示
3. 行編集付きで 1 行入力を取得
4. 空行/コメント行なら何もせず戻る
5. トークナイズ（クォート、演算子、コメント、最小エスケープ、未対応検出）
6. 構文解析（`|` / `&&` / `||` / `;` / リダイレクト制約を検査し、ASTへ）
7. 実行（builtins または外部実行、`last_status` 更新）
8. ループ継続（EOF なら `exit(last_status)`）

## 3.2 スクリプトモード処理フロー（概略）
0.0.3 継承。`ush <script>` でファイルを開き、先頭 `#!` 行は無視し、以降 1 行ずつ評価する。

- エラーでも次の行へ進む（fail-fast なし）
- `exit` builtin が実行されたらその時点で終了

## 3.3 モジュール分割（責務）
0.0.3 の分割を維持し、0.0.4 の追加点を各モジュールに反映する。

- main
  - 対話/スクリプトの分岐、ループ、状態（`last_status`）管理、SIGINT 方針
- prompt
  - `USH_PS1`/`PS1`/デフォルト選択、最小展開（`\u` `\w` `\$` `\\`）
- lineedit
  - raw mode 入力、カーソル移動、削除、履歴、Tab 補完（0.0.4 で「現在トークン」へ拡張）
- tokenize
  - 文字列→トークン列（クォート処理、演算子トークン化、コメント除去、最小エスケープ、未対応検出）
- parse
  - トークン列→AST（`PIPELINE`/`AND`/`OR`/`SEQ`）
  - 構文制約（1段パイプ、リダイレクト位置、`<`/`>` 適用範囲、`;` 空要素禁止）
- expand
  - 変数展開（`$VAR`/`$?`/`${VAR}`）
  - チルダ展開（`~`/`~/...`）
- builtins
  - `cd` `pwd` `export` `exit` `help`
- exec
  - AST 評価（短絡、順次実行 `;`、パイプ、リダイレクト、PATH 探索、fork/exec/wait）
  - argv の展開（変数/チルダ）後にグロブを適用（未クォートのみ）
  - `ENOEXEC` のみ `/bin/sh` フォールバック

---

# 4. データ設計

## 4.1 状態（`last_status`）
- ush は `last_status`（初期値 0）を保持する（0.0.3 継承）。
- `;` を導入しても規約は変えず、「最後に実行した要素」の終了コードを保持する（仕様書 8.2）。

## 4.2 トークン（token）
- kind
  - WORD
  - 演算子: `|` `&&` `||` `;` `<` `>` `>>`
- quote
  - 未クォート / シングル / ダブル
- text
  - WORD の場合のみ有効。

### 4.2.1 最小エスケープの内部表現
- tokenize は、エスケープされた 1 文字 `X` を「リテラル」として保持する必要がある。
- 実装は「内部マーカー（制御文字）+ 実文字」の 2 バイトで保持する方式を採用する。
  - 例: 入力 `\*` は WORD 内で `[ESC]['*']` として保持
- 目的
  - expand（`$`）や glob（`* ? [ ]`）で、エスケープされた文字をメタ文字として扱わない。

---

# 5. 入力設計（line editor）

## 5.1 前提
- 対話入力は端末を raw mode（canonical off, echo off）にして 1 文字ずつ処理する（0.0.3 継承）。

## 5.2 Tab 補完（0.0.4 拡張）
- 補完対象
  - 0.0.3: 先頭トークン（コマンド名）のみ
  - 0.0.4: カーソル位置を含む「現在トークン」
- 制限
  - クォートやバックスラッシュ（エスケープ）を含む行は「複雑ケース」として補完しない（誤動作回避）。

補完ソース
- 先頭トークン（コマンド名）: builtins + `$PATH` から候補列挙
- それ以外（引数・パス）
  - トークンに `/` を含む: そのディレクトリを走査
  - `/` を含まない: `.` を走査

挙動
- 候補 1 つ: 確定補完（バッファ書き換え＋再描画）
- 候補複数: 共通プレフィックス分だけ伸長
- 伸長不可: 候補一覧を表示して再描画
- ディレクトリ候補には末尾 `/` を付けてよい

---

# 6. 字句設計（tokenize）

## 6.1 演算子
- 空白の有無に関わらず独立トークンとして認識する。
  - `|` `&&` `||` `<` `>` `>>` `;`
- クォート内では演算子は文字として扱う。

## 6.2 コメント
- 未クォートで「トークン先頭の `#`」をコメント開始として扱い、以降を無視する（0.0.3 継承）。

## 6.3 クォート
- `'...'` : 展開なし
- `"..."` : 変数展開のみ（`$VAR`/`$?`/`${VAR}`）
- 未閉鎖クォートは `syntax error`（`last_status=2`）

## 6.4 最小エスケープ（0.0.4 追加）
- 未クォート
  - `\X` の X が仕様書 10.2 の対象文字なら、X をリテラルとして取り込む。
  - 対象外の `\X` は `\` を通常文字として扱い、エラーにはしない。
- ダブルクォート内
  - `\"` / `\\` / `\$` のみ特別扱い（仕様書 10.3）。
- シングルクォート内
  - エスケープは解釈しない。

## 6.5 未対応検出
- 単体 `&`
- `(` `)` `{` `}`
- 行継続（`\` + 改行）は未対応（0.0.4でもやらない）

補足：
- 変数展開の `${NAME}` で用いる `{` `}` は例外として許可する（仕様書 11.1）。

未対応検出時:
- stderr: `ush: unsupported syntax`
- `last_status=2`

---

# 7. 構文設計（parse）

## 7.1 優先順位
- `|` が高い
- `&&` / `||` が中
- `;` が低い（左から順に実行）

## 7.2 文法（概略）
仕様書 7.2 に準拠。

- `seq := list (";" list)*`
- `;` は空要素を許さない（先頭/末尾/連続 `;;` は `syntax error`）。

---

# 8. 展開設計（expand + glob）

## 8.1 変数展開
- 対応
  - `$NAME` / `${NAME}` / `$?`
- 未定義変数は空文字
- シングルクォート内は展開しない
- 未対応（検出してエラー）
  - `${NAME:-default}` 等の派生形
  - `$1` などの位置パラメータ
  - `$(...)` / バッククォート

## 8.2 グロブ展開（0.0.4 追加）
- 対象
  - 未クォート WORD に `* ? [ ]` が含まれる場合
- マッチ 0 件
  - エラーにせず、そのまま argv に残す（仕様書 12.4）
- `[a-z]` の範囲指定
  - 未対応として検出し `unsupported syntax`（仕様書 12.2）
- 並び順
  - `readdir()` 順でよい（安定ソートしない）

補足（仕様の写像として明文化）:
- リダイレクト対象パスも WORD であるため、未クォートならグロブ展開対象とする。
- 仕様書 12.4 により「0件マッチはエラーにしない」ため、リダイレクトで 0 件マッチした場合も WORD は展開せず 1 語のまま残り、結果として `open()` 失敗（`ush: open: ...` / `last_status=1`）になり得る。
- リダイレクトは 1 パスに確定する必要があるため、（0件ではなく）グロブが **複数語**に展開された場合は曖昧さとして `syntax error`（`last_status=2`）とする。

---

# 9. 実行設計（exec）

## 9.1 条件実行（`&&`, `||`）
0.0.3 継承。

## 9.2 逐次実行（`;`）
- `A ; B` は `A` を実行してから必ず `B` を実行する。
- `last_status` は `B` の結果で更新される（仕様書 8.2）。

## 9.3 リダイレクト失敗の扱い（重要）
0.0.3 継承。

- リダイレクト対象ファイルは **fork 前に親で `open()` して成功確認**する。
- 1 つでも失敗したら、その行は **1 つも fork/exec しない**（部分実行しない）。

## 9.4 builtins
0.0.3 継承。

- builtins は親プロセスで実行。
- builtins は「パイプなし」かつ「リダイレクトなし」の場合のみ対応。

---

# 10. エラー設計（運用観点）

## 10.1 メッセージ
- 未対応: `ush: unsupported syntax`（`last_status=2`）
- 構文: `ush: syntax error`（`last_status=2`）
- open 失敗: `ush: open: <strerror>`（`last_status=1`）

## 10.2 失敗時の優先順位
仕様書 5.3 に準拠し、字句/構文段階の失敗を最優先とする。

---

# 11. 受け入れ（基本設計観点）
- 仕様書 21 章の受け入れ項目が、この基本設計に矛盾なく写像されていること。
- 特に以下が成立していること:
  - `;` の順次実行と空要素の `syntax error`
  - `${VAR}` の展開と派生形の `unsupported syntax`
  - グロブ（未クォートのみ、0件はそのまま、`[a-z]` 拒否）
  - 最小エスケープにより `\*` 等でグロブ/展開を抑止できる
  - Tab 補完が「現在トークン」に対して動作し、パス補完が可能
  - 0.0.3 の成立条件（`&&/||` 短絡、1段パイプ、fork前open）が維持される
